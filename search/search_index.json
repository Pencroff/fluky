{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Happening by or depending on chance in Golang.</p>"},{"location":"#overview","title":"Overview","text":"<p>Fluky Library offers a wide range of methods to generate various types of random values. It relies on the standard <code>rand.Rand</code> located in <code>math/rand</code> and includes several random number generators such as pcg, small prng, splitmix64, xoshiro256++, and xoshiro256**.  These generators have been evaluated for their quality using the <code>dieharder</code> test suite.</p> <p>Please check dieharder results in repo.</p>"},{"location":"#install","title":"Install","text":"<pre><code>go get -u github.com/Pencroff/fluky\n</code></pre>"},{"location":"#usage-example","title":"Usage example","text":"<pre><code>package main\nimport (\n\"fmt\"\n\"github.com/Pencroff/fluky\"\nsrc \"github.com/Pencroff/fluky/source\"\n\"math/rand\"\n)\nfunc main() {\ns := src.NewPcgSource(0)\nr := rand.New(s)\nflk := fluky.NewFluky(r)\nfmt.Println(flk.Uint64())\n}\n</code></pre>"},{"location":"sources/","title":"External Sources","text":"<p>Fluky library provides a set of external sources for random number generation. They have a good statistical quality and are fast for general purpose cases. All sources are implement the <code>Source</code> and  <code>Source64</code> interfaces from <code>math/rand</code> package.</p> <p>Import all sources</p> <pre><code>import \"github.com/Pencroff/fluky/sources\"\n</code></pre>"},{"location":"sources/#splitmix64","title":"SplitMix64","text":"<p>Reference</p> <p>splitmix64.c</p> <p>SplitMix64 is a pseudorandom number generator (PRNG) algorithm that generates a 64-bit output using a 64-bit seed. It works by repeatedly applying a basic function to the seed value, but it may not provide enough randomness for some applications, and its output is not suitable for cryptographic purposes. However, SplitMix64 is known for  its speed and simplicity, and it can be used as a basic building block for more complex PRNGs.</p> <p>Current implementations of <code>xoshiro256++</code> and <code>xoshiro256**</code> use <code>SplitMix64</code> as a seed generator.</p> <p>Usage</p> <pre><code>src := sources.NewSplitMix64Source(0) // where 0 is a seed, int64\n</code></pre> SplitMix64 implementation <p><code>state</code> has <code>uint64</code> type.</p> <pre><code>func (s *SplitMix64Source) Uint64() uint64 {\ns.state += 0x9e3779b97f4a7c15\nz := s.state\nz ^= z &gt;&gt; 30\nz *= 0xbf58476d1ce4e5b9\nz ^= z &gt;&gt; 27\nz *= 0x94d049bb133111eb\nz ^= z &gt;&gt; 31\nreturn z\n}\n</code></pre>"},{"location":"sources/#xoroshiro256-xoroshiro256","title":"Xoroshiro256++ / Xoroshiro256**","text":"<p>Reference</p> <ul> <li>xoshiro generators</li> <li>xoroshiro256++</li> <li>xoroshiro256**</li> </ul> <p>Xoshiro is a family of fast and efficient pseudorandom number generators (PRNGs) designed by David Blackman and Sebastiano Vigna. They are known for producing high-quality output with a relatively small state size, using a combination of bitwise operations and nonlinear transformations. Fluky provides Xoroshiro256++ and Xoroshiro256** implementations (64 bit output and 2256-1 period), but they are not suitable for cryptographic purposes due to vulnerabilities in their design. Overall, Xoshiro generators are ideal for simulations, games, and other applications where high-quality randomness is required.</p> <p>Fluky implementation of <code>xoshiro256++</code> and <code>xoshiro256**</code> use <code>SplitMix64</code> as a seed generator.</p> <p>Usage</p> xoshiro256++xoshiro256** <pre><code>src := sources.NewXoshiro256ppSource(0) // where 0 is a seed, int64\n</code></pre> <pre><code>src := sources.NewXoshiro256ssSource(0) // where 0 is a seed, int64\n</code></pre> <p>Xoroshiro256 implementations provide <code>Jump</code> and <code>LongJump</code> methods which is return new source with current state, and move state of existing source to 2128 and 2192 iterations accordingly.</p> <pre><code>s := src.(*src.Xoshiro256ppSource) // Same cast to Xoshiro256ssSource:\n// s := src.(*src.Xoshiro256ssSource)\n// Note: state A\ns1 := s.Jump() // Note: s1 is state A\n// s is now state B (equivalent to 2^128 iterations of s.Uint64())\ns2 := s.LongJump()\n// Note: s2 is state B\n// s is now state C (equivalent to 2^192 iterations of s.Uint64())\n</code></pre> Xoroshiro256 implementation <p><code>s0..s4</code> have <code>uint64</code> type.</p> xoshiro256++xoshiro256**Seed (same for both) <pre><code>func (x *Xoshiro256ppSource) Uint64() uint64 {\nres := bits.RotateLeft64(x.s0+x.s3, 23) + x.s0\nt := x.s1 &lt;&lt; 17\nx.s2 ^= x.s0\nx.s3 ^= x.s1\nx.s1 ^= x.s2\nx.s0 ^= x.s3\nx.s2 ^= t\nx.s3 = bits.RotateLeft64(x.s3, 45)\nreturn res\n}\n</code></pre> <pre><code>func (x *Xoshiro256ssSource) Uint64() uint64 {\nres := bits.RotateLeft64(x.s1*5, 7) * 9\nt := x.s1 &lt;&lt; 17\nx.s2 ^= x.s0\nx.s3 ^= x.s1\nx.s1 ^= x.s2\nx.s0 ^= x.s3\nx.s2 ^= t\nx.s3 = bits.RotateLeft64(x.s3, 45)\nreturn res\n}\n</code></pre> <pre><code>sm := NewSplitMix64Source(seed)\nx.s0 = sm.Uint64()\nx.s1 = sm.Uint64()\nx.s2 = sm.Uint64()\nx.s3 = sm.Uint64()\n</code></pre>"},{"location":"sources/#pcg-xsl-rr","title":"PCG-XSL-RR","text":"<p>Reference</p> <ul> <li>PCG</li> <li>PCG-XSL-RR - 6.3.3, page 44</li> <li>Practical seed-recovery for the PCG...</li> </ul> <p>PCG (Permuted Congruential Generator) is a family of pseudorandom number generators (PRNGs) designed by Melissa O'Neill. They are known for their speed, statistical quality, and flexibility, and can produce high-quality random numbers with relatively small state sizes. PCG generators work by combining a linear congruential generator (LCG) with a permutation function that shuffles the output, resulting in improved statistical properties. Fluky provides PCG-XSL-RR implementation (128 bit state, 64 bit output), and they are suitable for variety of  applications, such as games, simulations (used in the NumPy scientific computing package). PCG-XSL-RR is not suitable for cryptographic purposes.</p> <p>Usage</p> <pre><code>src := sources.NewPcgXslRrSource(0) // where 0 is a seed, int64\n</code></pre> PCG-XSL-RR implementation <p><code>state</code>, <code>mul</code> and <code>inc</code> have <code>uint128</code> type.</p> <pre><code>func (s *PcgXslRrSource) Uint64() uint64 {\ns.step()\nreturn s.stateToValue()\n}\nfunc (s *PcgXslRrSource) step() {\ns.state = s.state.Mul(s.mul).Add(s.inc)\n}\nfunc (s *PcgXslRrSource) stateToValue() (v uint64) {\nv = s.state.Lo ^ s.state.Hi\nrot := int(s.state.Rsh(122).Lo&amp;0x3F) * -1\nv = bits.RotateLeft64(v, rot)\nreturn\n}\n</code></pre>"},{"location":"sources/#small-prng","title":"Small PRNG","text":"<p>Reference</p> <ul> <li>A small noncryptographic PRNG</li> <li>Bob Jenkins's Small PRNG...</li> </ul> <p>This fast and compact pseudorandom number generator is appropriate for large statistical computations, but not intended for cryptographic purposes due to its lack of sufficient strength. The cycle length is not guaranteed to meet a minimum requirement, but on average, it is estimated to produce approximately 2126 results. Fluky provides Small PRNG implementation with 256 bit state and 64 bit output. Upon conducting multiple iterations of the dieharder test suite, the Small PRNG exhibited just 0-2 weak results (of 114 tests).</p> <p>Usage</p> <pre><code>src := sources.NewSmallPrngSource(0) // where 0 is a seed, int64\n</code></pre> Small PRNG implementation <p><code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> have <code>uint64</code> type.</p> <pre><code>    func (s *SmallPrngSource) Uint64() uint64 {\ne := s.a - bits.RotateLeft64(s.b, 7)\ns.a = s.b ^ bits.RotateLeft64(s.c, 13)\ns.b = s.c + bits.RotateLeft64(s.d, 37)\ns.c = s.d + e\ns.d = e + s.a\nreturn s.d\n}\n</code></pre>"},{"location":"sources/#summary","title":"Summary","text":""},{"location":"sources/#statistical-quality-dieharder","title":"Statistical quality (dieharder)","text":"<p>SEED: 1234567</p> <p>Test data: 229GiB</p> Name Time PASS WEAK FAIL Total Built In 35:33 112 2 0 114 PCG-XSL-RR 36:12 112 2 0 114 Small Prng 37:49 114 0 0 114 Xoshiro256++ 39:35 112 2 0 114 Xoshiro256** 37:01 108 6 0 114 SplitMix64 38:06 113 1 0 114 <p>Reference</p> <ul> <li>Detailed results available in the repo's <code>dieharder-source</code> folder.</li> <li>Built In source is a default Go source - ref</li> </ul>"},{"location":"sources/#statistical-quality-draw-test","title":"Statistical quality (draw test)","text":"Expand to check results (each picture is 2 Mb) Built InSplitMix64Xoshiro256++Xoshiro256**PCG-XSL-RRSmall Prng"},{"location":"sources/#performance","title":"Performance","text":"<p>Manual run</p> <pre><code>go test -bench=. -timeout 30m ./fluky_testing\n</code></pre> <p> TBW - requires tests on Intel, M2, with latest Go version </p>"},{"location":"api/","title":"Fluky API","text":""},{"location":"api/#new-fluky","title":"New Fluky","text":"<pre><code>package main\nimport (\n\"fmt\"\nf \"github.com/Pencroff/fluky\"\nsrc \"github.com/Pencroff/fluky/source\"\n\"math/rand\"\n)\nfunc main() {\ns := src.NewSplitMix64Source(1234567)   // create source\nr := rand.New(s)                        // create rand.Rand instance\nflk := f.NewFluky(r)                    // create fluky instance\n// ready to use\nfmt.Println(flk.Bool()) // true\nfmt.Println(flk.Integer()) // 3203168211198807973\n// with parameters\nfmt.Println(flk.Bool(f.WithLikelihood(0.25))) // 25% chance to return true\nfmt.Println(flk.Integer(f.WithIntRange(0, 100))) // 0..99, 100 is excluded\n}\n</code></pre> <p>All Fluky methods accept set of optional parameters. They are used for result customization of the method.</p>"},{"location":"api/#sections","title":"Sections","text":"<ul> <li>Basic</li> <li>Helpers</li> </ul>"},{"location":"api/basic/","title":"Basic","text":""},{"location":"api/basic/#bool","title":"Bool","text":"<p><code>Bool</code> returns a random bool value. By default, values have equal probability.</p> <pre><code>flk.Bool() // true\n</code></pre>"},{"location":"api/basic/#parameters","title":"Parameters","text":""},{"location":"api/basic/#withlikelihood","title":"WithLikelihood","text":"<p><code>WithLikelihood</code> parameter allows to set the likelihood of the <code>True</code> result. It accepts <code>v</code>, float64 value in the range [0, 1].</p> <pre><code>flk.Bool(f.WithLikelihood(0.25)) // 25% chance to return true\n</code></pre>"},{"location":"api/basic/#integer","title":"Integer","text":"<p><code>Integer</code> returns a random integer value. By default, the range is from -263 to 263-1. The max value not included in the range.</p> <pre><code>flk.Integer() // 3203168211198807973\n// above is same as\nflk.Integer(f.WithIntRange(math.MinInt64, math.MaxInt64))\n</code></pre>"},{"location":"api/basic/#parameters_1","title":"Parameters","text":""},{"location":"api/basic/#withintrange","title":"WithIntRange","text":"<p><code>WithIntRange</code> parameter allows to set the range of the result. It accepts <code>min</code> and <code>max</code> values, <code>int</code>. The <code>max</code> value not included in the range.</p> <pre><code>flk.Integer(f.WithIntRange(0, 10)) // 8, 0 &lt;= result &lt; 10\n</code></pre>"},{"location":"api/basic/#float","title":"Float","text":"<p><code>Float</code> returns a random float64 value. By default, the range is from 0 to 1 and precision not limited (<code>-1</code>). The max value not included in the range.</p> <pre><code>flk.Float() // 0.5322073040624193\n// above is same as\nflk.Float(f.WithFloatRange(0, 1), f.WithPrecision(-1))\n</code></pre>"},{"location":"api/basic/#parameters_2","title":"Parameters","text":""},{"location":"api/basic/#withfloatrange","title":"WithFloatRange","text":"<p><code>WithFloatRange</code> parameter allows to set the range of the result. It accepts <code>min</code> and <code>max</code> values, <code>float64</code>. The <code>max</code> value not included in the range.</p> <pre><code>flk.Float(f.WithFloatRange(0, 10)) // 8.5322073040624193, 0 &lt;= result &lt; 10\n</code></pre>"},{"location":"api/basic/#withprecision","title":"WithPrecision","text":"<p><code>WithPrecision</code> parameter allows to set the precision of the result. It accepts <code>p</code>, <code>int8</code> value. The <code>p</code> value is the number of digits after the decimal point. The negative value does not change the result. Max value is 20.</p> <pre><code>flk.Float(f.WithPrecision(0)) // 1\nflk.Float(f.WithPrecision(2)) // 0.53\nflk.Float(f.WithPrecision(-1)) // 0.5322073040624193\n</code></pre>"},{"location":"api/helpers/","title":"Fluki helpers","text":""},{"location":"api/helpers/#weighted","title":"Weighted","text":""},{"location":"api/helpers/#pickone","title":"PickOne","text":""}]}